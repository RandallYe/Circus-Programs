\begin{zsection}
	\SECTION\ ESELSystem2 \parents\ circus\_toolkit
\end{zsection}

Additional constant $MAX\_GATEWAY$ stands for maximum number of gateways.
\begin{axdef}
    MAX\_ESEL: \nat \\
    MAX\_PID: \nat \\
    MAX\_GATEWAY: \nat
\end{axdef}

Similarly, $GID$ gives all identities for gateways.
\begin{zed}
    ESID ::= ES \ldata 1 \upto MAX\_ESEL \rdata \\
    PID ::= PD \ldata 1 \upto MAX\_PID \rdata \\
    GID ::= GW \ldata 1 \upto MAX\_GATEWAY \rdata 
\end{zed}

The map from ESELs to gateways, $gwmap$, is defined as a total function. One ESEL is linked to up to one gateway. However, one gateway may associate with multiple ESELs.
\begin{axdef}
    % total function and each ESEL must be assigned to corresponding gateway
    gwmap: ESID \fun GID
    \where
    gwmap = \{(ES~1, GW~1), (ES~2, GW~1), (ES~3, GW~2)\}
\end{axdef}

\begin{zed}
    Price == \nat
\end{zed}

\begin{zed}
    UStatus ::= uok | ufail
\end{zed}

%The response from this program to the environment is a set of product identities of which the price is not updated successfully due to 1) no linked ESEL ID to the product or 2) failed update to its linked ESEL. The first reason is given the status constant $NA$ and the second is provided the constructor $fail\ldata ESID \rdata$.
\begin{zed}
    % NA - no correponding ESEL ID for the product
    FStatus ::= fail \ldata ESID \rdata | NA 
\end{zed}

%Two channels are provided to update the map from ESEL ID to product ID. $updateallmap$ will clear all stored map and use the input map as new map, while $updatemap$ just updates a partial map. In this map, one ESEL can be linked to up to one product. However, one product may associate with multiple ESELs. 
\begin{circus}
	\circchannel\ updateallmap: ESID \pfun PID \\
	\circchannel\ updatemap: ESID \pfun PID
\end{circus}

%Similarly, two channels are provided to update the price information. $updateallprice$ will clear all price information and use the input price information as new price, while $updateprice$ just updates price partially.  
\begin{circus}
	\circchannel\ updateallprice: PID \pfun Price \\
	\circchannel\ updateprice: PID \pfun Price
\end{circus}

%The $update$ channel gives a signal to the program to start update process.
\begin{circus}
	\circchannel\ update
\end{circus}

%The $failures$ channel returns all failed products and related error reasons after update.
\begin{circus}
	\circchannel\ failures: PID \pfun \power~FStatus 
\end{circus}

%The internal $resp$ event is used to collect update responses from all ESELs.
\begin{circus}
    % inside
	\circchannel\ resp: PID \cross FStatus \\
    \circchannel\ terminate \\
    \circchannelset\ RespInterface == \lchanset resp, terminate \rchanset 
\end{circus}

The channels below are used to communicate between the server and gateways, or between gateway internals. The server uses $gupdateprice$ to send price information with ESEL IDs to the corresponding gateway, while $gfailure$ is used to get back the udpate result from the gateway.
\begin{circus}
    % price info to start a new update
	\circchannel\ gupdateprice: GID \cross (ESID \pfun Price) \\
    % update result response
	\circchannel\ gfailure: GID \cross \power~ESID \\
\end{circus}
$gresp$ and $gterminate$ are used in the internal of gateways to collection update results from each ESEL and terminate after collection.
\begin{circus}
    % gateway internal response collection
	\circchannel\ gresp: ESID \\
	\circchannel\ gterminate \\
    \circchannelset\ GRespInterface == \lchanset gresp, gterminate \rchanset 
\end{circus}

%This $uupdate$ event is to update one ESEL to the specific price, and $ures$ for update response from this ESEL.
\begin{circus}
    % unit
	\circchannel\ uupdate: ESID \cross Price \\
	\circchannel\ ures: ESID \cross UStatus \\
	\circchannel\ uinit, finishuinit\\
	\circchannel\ udisplay \\
	\circchannel\ finishudisplay
\end{circus}

And $display$ is used to synchronise the show of price on all ESELs at the same time and $finishdisplay$ is used to wait for display completion of all ESELs.
\begin{circus}
	\circchannel\ init, finishinit \\
	\circchannel\ display \\
	\circchannel\ finishdisplay
\end{circus}

These channels are for communication between ESEL controllers to their linked displays. The $write$ event writes price to its display, and the $read$ event reads price from its display. $ondisplay$ turns on the related display and $offdisplay$ terns off it.
\begin{circus}
	\circchannel\ write: ESID \cross Price \\
	\circchannel\ read: ESID \cross Price \\
	\circchannel\ ondisplay: ESID \\
	\circchannel\ offdisplay: ESID 
\end{circus}

\paragraph{ESEL Server Process}
The process for overall control of the system, named $ESELServer$, is defined as an explicitly defined process.

\begin{circus}
	\circprocess\ ESELServer \circdef \circbegin \\
\end{circus}

The $ESELServer$ has three state components: $pumap$ for mapping from ESELs to products, $ppmap$ for mapping from products to their price, and $response$ for the response of one update to the environment.
\begin{circusaction}
    	\t1 \circstate\ State == [~ pumap: ESID \pfun PID; ppmap: PID \pfun Price; \\
            \t2 response: PID \pfun (\power~FStatus) ~]
\end{circusaction}
Initially, these three state components all are empty.
\begin{zed}
    	\t1	Init == [~ (State)' | pumap' = \emptyset \land ppmap' = \emptyset \land response' = \emptyset ~]
\end{zed}
The $UpdateMap$ schema updates part of the ESELs to products map according to the input map, while the $UpdateAllMap$ schema discards all map and uses new input map as $pumap$. 
\begin{zed}
        \t1 UpdateMap == [~ \Delta State; map?: ESID \pfun PID | \\
            \t2 pumap' = pumap \oplus map? \land ppmap' = ppmap \land response' = response ~] \\
        \t1 UpdateAllMap == [~ \Delta State; map?: ESID \pfun PID | \\
            \t2 pumap' = map? \land ppmap' = ppmap \land response' = response ~] 
\end{zed}
The $NewPrice$ updates part of price information stored, while the $AllNewPrice$ discards all price information stored and uses input price as $ppmap$. 
\begin{zed}
        \t1 NewPrice == [~ \Delta State; price?: PID \pfun Price | \\
            \t2 ppmap' = ppmap \oplus price? \land pumap' = pumap \land response' = response ~] \\
        \t1 AllNewPrice == [~ \Delta State; price?: PID \pfun Price | \\
            \t2 ppmap' = price? \land pumap' = pumap \land response' = response ~]
\end{zed}
$AUpdatemap$ is an action defined to update ESELs to products map: either partial update by $updatemap$ event or complete update by $updateallmap$ event.
\begin{circusaction}
        \t1 AUpdatemap \circdef updatemap?map \then \lschexpract UpdateMap \rschexpract \\
            \t2 \extchoice updateallmap?map \then \lschexpract UpdateAllMap \rschexpract \\
\end{circusaction}
Similarly, $ANewPrice$ is an action defined to update products to price map: either partial update by $updateprice$ event or complete update by $updateallprice$ event.
\begin{circusaction}
        \t1 ANewPrice \circdef updateprice?price \then \lschexpract NewPrice \rschexpract \\
            \t2 \extchoice updateallprice?price \then \lschexpract AllNewPrice \rschexpract \\
\end{circusaction}

If the update to an ESEL fails, $AUpdateUnitFail$ sends the failure by $resp$ to the response collection action $CollectResp$.
\begin{circusaction}
        \t1 AUpdateUnitFail \circdef  eid: ESID \circspot resp.(pumap(eid)).(fail~eid) \then \Skip \\ 
\end{circusaction}

Or if the product has not been allocated the corresponding ESELs, it sends back a response to state this error $NA$. The behaviour is defined in the $AUpdateNoUnit$ action. 
\begin{circusaction}
        \t1 AUpdateNoUnit \circdef  pid: PID \circspot resp.pid.NA \then \Skip \\ 
\end{circusaction}

For all products without associate ESELs, they send the failures independently. 
\begin{circusaction}
        \t1 ARespNoUnit \circdef \Interleave pid: (\dom~ppmap \setminus \ran~pumap) \linter \emptyset \rinter \circspot \\
        \t2 AUpdateNoUnit(pid) \\ 
\end{circusaction}

For each gateway, $AUpdateGateways$ sends all price for the ESELs which are linked to the gateway and gets back update result. Then for each failure, the action passes it to $AUpdateUnitFail$, and finally writes to $response$.
\begin{circusaction}
    % (
    %   (pumap \comp ppmap) % composition to get a map from ESEL -> Price
    %   \dres               % domain restricted to all ESELs from this gateway
    %   (\dom (gwmap \rres \{gid\})))   % range restriction to get all ESELs mapped to this gateway 
    \t1 AUpdateGateway \circdef  gid: GID \circspot \\
        \t2 gupdateprice.gid!( (\dom~(gwmap \rres \{gid\})) \dres (pumap \comp ppmap)) \then \\
        \t2 gfailure.gid?uids \then (\Interleave uid:uids \linter \emptyset \rinter \circspot AUpdateUnitFail(uid)) \\ 
\end{circusaction}

Update of price to ESELs is an interleave of $AUpdateGateway$ for all gateways.
\begin{circusaction}
    \t1 AUpdateGateways \circdef \Interleave gid:GID \linter \emptyset \rinter \circspot AUpdateGateway(gid)
\end{circusaction}

Then the update of all products, given in the action $AUpdateProducts$, is the interleave of the update of price to ESELs through gateways and the action for the case without associate ESELs. Then it follows a $terminate$ event to finish the update.
\begin{circusaction}
    \t1 AUpdateProducts \circdef (AUpdateGateways \linter \emptyset | \emptyset \rinter ARespNoUnit) \circseq \\
        \t2 terminate \then \Skip
\end{circusaction}

\begin{zed}
    \t1 AddOneFailure == [~ \Delta State; pid?:PID; fst?:FStatus | \\
        \t2 (pid? \in \dom~response \implies \\
            \t3 response' = response \oplus \{pid? \mapsto (response(pid?) \cup \{fst?\}) \}) \land \\
        \t2 (pid? \notin \dom~response \implies \\
            \t3 response' = response \cup \{pid? \mapsto \{fst?\} \}) \land \\
        \t2 ppmap' = ppmap \land pumap' = pumap ~]
\end{zed}

The $CollectResp$ action is to collect responses from all units and write them into the $response$ variable. It recursively waits for the response from the units, or terminates if required.
\begin{circusaction}
        \t1 CollectResp \circdef \circmu X \circspot \\
            \t2 ((resp?pid?fst \then \lschexpract AddOneFailure \rschexpract \circseq X) \extchoice terminate \then \Skip) 
\end{circusaction}

Then update of all products and response collection behaviours are put together into $AUpdateResp$ action. It is a parallel composition of $AUpdateProducts$ and $CollectResp$ actions and they are synchronised with $resp$ and $terminate$ events. Finally, these internal events are hidden.
\begin{circusaction}
        \t1 AUpdateResp \circdef \\
            \t2 (AUpdateProducts \lpar \emptyset | RespInterface | \{ response \} \rpar CollectResp ) \\
            \t2 \circhide RespInterface \\
\end{circusaction}

The overall price update action is given in $AUpdatePrice$, which accepts a $update$ event from its environment, then clears $response$, updates the price, sends $display$ event to make all ESELs show their price at the same time, then feeds back the response to the environment.
\begin{circusaction}
        \t1 AUpdatePrice \circdef update \then response := \emptyset \circseq \\
            \t2 AUpdateResp \circseq display \then finishdisplay \then failures.response \then \Skip \\ 
\end{circusaction}

The overall behaviour of the $ESELServer$ process is given by its main action. It initializes at first, then repeatedly provides ESEL map update, price map, or price update to its environment.
\begin{circusaction}
	\t1 \circspot \lschexpract Init \rschexpract \circseq init \then finishinit \then \Skip \circseq \\
    \t2 (\circmu X \circspot (AUpdatemap \extchoice ANewPrice \extchoice AUpdatePrice) \circseq X) \\
\end{circusaction}
\begin{circus}
	\circend
\end{circus}

\paragraph{Gateway Process}

The $Gateway$ process is defined as parametrised process.
\begin{circus}
	\circprocess\ Gateway \circdef gid: GID \circspot \circbegin \\
\end{circus}

It has two state components: $pumap$ for the map from ESELs to price, and $failed$ for a set of ESELs which update unsuccessfully.
\begin{circusaction}
    	\t1 \circstate\ State == [~ pumap: ESID \pfun Price; failed: \power~ESID ~]
\end{circusaction}

Initially, both are empty.
\begin{zed}
    	\t1	Init == [~ (State)' | pumap' = \emptyset \land failed' = \emptyset ~]
\end{zed}

The map only can be updated completely and can not be updated partially.
\begin{zed}
        \t1 UpdateAllMap == [~ \Delta State; map?: ESID \pfun Price | \\
            \t2 pumap' = map? \land failed' = failed ~] 
\end{zed}

The map is updated after input from $ESELServer$ through the $gupdateprice$ channel.
\begin{circusaction}
        \t1 AUpdateallmap \circdef gupdateprice.gid?map \then \lschexpract UpdateAllMap \rschexpract \\
\end{circusaction}

A parameterised action, $AUpdateUnitPrice$, is given to update the price (specified by the formal $pid$ parameter) to an ESEL (given by the formal $uid$ parameter). It sends the price to the specified ESEL by the $uupdate$ event, and then waits for the response from the ESEL. If the return status is not successful ($ufail$), it sends the result to response collection action $CollectResp$ below, then terminates. Otherwise, it terminates immediately.
\begin{circusaction}
        %
        \t1 AUpdateUnitPrice \circdef uid:ESID \circspot \\
            \t2 uupdate.uid.(pumap~uid) \then ures.uid?rst \then \\
            \t2 (\lcircguard rst = ufail \rcircguard \circguard gresp!uid \then \Skip \\
            \t2 \extchoice \lcircguard rst = uok \rcircguard \circguard \Skip)\\
\end{circusaction}

Updates of all ESELs in this gateway are put in an iterated interleave, then follow a $gterminate$ event to finish the updates.
\begin{circusaction}
        \t1 AUpdateAllUnits \circdef ((\Interleave eid: (\dom~pumap) \linter \emptyset \rinter \circspot AUpdateUnitPrice(eid)) \\
        \t2 \circseq gterminate \then \Skip) \\
\end{circusaction}

The $CollectResp$ action is to collect responses from all units and write them into the $response$ variable. It recursively waits for the response from the units, or terminates if required.
\begin{circusaction}
        \t1 CollectResp \circdef \circmu X \circspot \\
            \t2 ((gresp?uid \then failed := failed \cup \{ uid \} \circseq X) \extchoice gterminate \then \Skip) \\
\end{circusaction}

Then update of all products and response collection behaviours are put together into $AUpdateResp$ action. It is a parallel composition of $AUpdateProducts$ and $CollectResp$ actions and they are synchronised with $resp$ and $terminate$ events. Finally, these internal events are hidden.
\begin{circusaction}
        \t1 AUpdateResp \circdef \\
            \t2 (AUpdateAllUnits \lpar \emptyset | GRespInterface | \{ failed \} \rpar CollectResp ) \\
            \t2 \circhide GRespInterface \\
\end{circusaction}

The overall price update action is given in $AUpdatePrice$, which accepts a $gupdateprice$ event from its environment, then clears $failed$, updates the price, sends update results to the server, and waits for $display$ event to make all ESELs in this gateway show their price at the same time.
\begin{circusaction}
        \t1 AUpdatePrice \circdef AUpdateallmap \circseq failed := \emptyset \circseq \\
            \t2 AUpdateResp \circseq gfailure.gid!failed \then display \then udisplay \then \\
            \t2 finishudisplay \then finishdisplay \then \Skip \\ 
\end{circusaction}

The overall behaviour of the $Gateway$ process is given by its main action. It initializes at first, then repeatedly provides ESEL map update, price map, or price update to its environment.
\begin{circusaction}
	\t1 \circspot \lschexpract Init \rschexpract \circseq init \then uinit \then finishuinit \then finishinit \then \Skip \circseq \\
    \t2 (\circmu X \circspot (AUpdatePrice) \circseq X) \\
\end{circusaction}

\begin{circus}
	\circend
\end{circus}

%
\paragraph{ESEL Process}

Each ESEL is defined as a parameterised process with the formal parameter---ESEL ID.
\begin{circus}
	\circprocess\ ESEL \circdef eid:ESID \circspot \circbegin \\
\end{circus}

The process has two state components: $price$ for the price to display, and $status$ for the status of ESEL.
\begin{circusaction}
    	\t1 \circstate\ State == [~ price: Price; status: UStatus ~] \\
\end{circusaction}
Initially, the price is equal to 0 and the status is $uok$.
\begin{zed}
    	\t1	Init == [~ (State)' | price' = 0 \land status' = uok ~] \\
\end{zed}
The $Update$ action provides its environment ($Gateway$) the update of price for the associated product. It accepts the $uupdate$ event with the price, then writes the price to $price$. After that, it writes the price to the display unit, and reads back the value to compare with the original price. If it is equal, it sends back status $uok$ by the $ures$ event. Otherwise, it sends back status $ufail$. Accordingly, $status$ is updated.
\begin{circusaction}
        \t1 Update \circdef uupdate.eid?x \then price := x \circseq write.eid.price \then read.eid?y \\
            \t2 \then (\lcircguard y = price \rcircguard \circguard ures.eid.uok \then status := uok \\
            \t2 \,\,\,\,\,\, \extchoice \lcircguard y \neq price \rcircguard \circguard ures.eid.ufail \then status := ufail) \\
\end{circusaction}
The $Display$ action accepts the $udisplay$ event. If the status is $uok$, then the associated display is turned on. Otherwise, the display is turned off.
\begin{circusaction}
        \t1 Display \circdef udisplay \then (\\
            \t2 \,\,\,\, \lcircguard status = uok \rcircguard \circguard ondisplay.eid \then \Skip \\
            \t2 \extchoice \lcircguard status = ufail \rcircguard \circguard offdisplay.eid \then \Skip) \\
            \t2 \circseq finishudisplay \then \Skip
\end{circusaction}
\begin{circusaction}
        \t1 NotUpdateDisplay \circdef udisplay \then offdisplay.eid \then finishudisplay \then \Skip \\
\end{circusaction}
The initial behaviour of the process is given in the action $AInit$ which initialises the state at first, and then turns off the display.
\begin{circusaction}
        \t1 AInit \circdef \lschexpract Init \rschexpract \circseq uinit \then offdisplay.eid \then finishuinit \then \Skip\\
\end{circusaction}
The overall behaviour of the process is given by its main action. It specifies that after initialisation the process repeatedly provides update or display to its environment.
\begin{circusaction}
	    \t1 \circspot AInit \circseq (\circmu X \circspot ( (Update \circseq Display) \extchoice NotUpdateDisplay) \circseq X) \\
\end{circusaction}
\begin{circus}
	\circend
\end{circus}

\paragraph{System}
\begin{circus}
    \circchannelset\ InterESELInterface == \lchanset uinit, finishuinit, \\
                \t5 udisplay, finishudisplay \rchanset \\
    \circprocess\ ESELS \circdef gid:GID \circspot \\ 
        \t1 (\Parallel eid: (\dom~(gwmap \rres \{gid\})) \lpar InterESELInterface \rpar \circspot ESEL(eid)) \\
\end{circus}

\begin{circus}
    \circchannelset\ InterGWInterface == \lchanset init, finishinit, display, finishdisplay \rchanset \\
    \circchannelset\ GWESELInterface == \lchanset uinit, finishuinit, uupdate, ures, \\
                \t5 udisplay, finishudisplay \rchanset \\
    \circprocess\ Gateways \circdef \Parallel gid: GID \lpar InterGWInterface \rpar \circspot \\
        \t1 (Gateway(gid) \lpar GWESELInterface \rpar ESELS(gid)) \circhide GWESELInterface \\
\end{circus}

\begin{circus}
    \circchannelset\ ServerGWInterface == \lchanset init, finishinit, gupdateprice, gfailure, \\
                \t5 display, finishdisplay \rchanset \\
    \circprocess\ ESELSystem2 \circdef \\
        \t1 (ESELServer \lpar ServerGWInterface \rpar Gateways) \circhide ServerGWInterface 
\end{circus}
